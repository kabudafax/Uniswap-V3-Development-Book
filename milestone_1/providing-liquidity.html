<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>提供流动性 - Uniswap V3 Development Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A book that teaches how to build a clone of Uniswap V3 in Solidity from scratch.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Uniswap V3 开发手册</a></li><li class="chapter-item expanded affix "><li class="part-title">里程碑 0. 背景</li><li class="chapter-item expanded "><a href="../milestone_0/introduction-to-markets.html"><strong aria-hidden="true">1.</strong> 市场介绍</a></li><li class="chapter-item expanded "><a href="../milestone_0/constant-function-market-maker.html"><strong aria-hidden="true">2.</strong> 恒定函数做市商</a></li><li class="chapter-item expanded "><a href="../milestone_0/uniswap-v3.html"><strong aria-hidden="true">3.</strong> Uniswap V3</a></li><li class="chapter-item expanded "><a href="../milestone_0/dev-environment.html"><strong aria-hidden="true">4.</strong> 开发环境</a></li><li class="chapter-item expanded "><a href="../milestone_0/what-we-will-build.html"><strong aria-hidden="true">5.</strong> 我们将要构建什么</a></li><li class="chapter-item expanded affix "><li class="part-title">里程碑 1. 第一次交换</li><li class="chapter-item expanded "><a href="../milestone_1/introduction.html"><strong aria-hidden="true">6.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../milestone_1/calculating-liquidity.html"><strong aria-hidden="true">7.</strong> 计算流动性</a></li><li class="chapter-item expanded "><a href="../milestone_1/providing-liquidity.html" class="active"><strong aria-hidden="true">8.</strong> 提供流动性</a></li><li class="chapter-item expanded "><a href="../milestone_1/first-swap.html"><strong aria-hidden="true">9.</strong> 第一次交换</a></li><li class="chapter-item expanded "><a href="../milestone_1/manager-contract.html"><strong aria-hidden="true">10.</strong> 管理合约</a></li><li class="chapter-item expanded "><a href="../milestone_1/deployment.html"><strong aria-hidden="true">11.</strong> 部署</a></li><li class="chapter-item expanded "><a href="../milestone_1/user-interface.html"><strong aria-hidden="true">12.</strong> 用户界面</a></li><li class="chapter-item expanded affix "><li class="part-title">里程碑 2. 第二次交换</li><li class="chapter-item expanded "><a href="../milestone_2/introduction.html"><strong aria-hidden="true">13.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../milestone_2/output-amount-calculation.html"><strong aria-hidden="true">14.</strong> 输出金额计算</a></li><li class="chapter-item expanded "><a href="../milestone_2/math-in-solidity.html"><strong aria-hidden="true">15.</strong> Solidity中的数学运算</a></li><li class="chapter-item expanded "><a href="../milestone_2/tick-bitmap-index.html"><strong aria-hidden="true">16.</strong> Tick位图索引</a></li><li class="chapter-item expanded "><a href="../milestone_2/generalize-minting.html"><strong aria-hidden="true">17.</strong> 通用铸造</a></li><li class="chapter-item expanded "><a href="../milestone_2/generalize-swapping.html"><strong aria-hidden="true">18.</strong> 通用交换</a></li><li class="chapter-item expanded "><a href="../milestone_2/quoter-contract.html"><strong aria-hidden="true">19.</strong> 报价合约</a></li><li class="chapter-item expanded "><a href="../milestone_2/user-interface.html"><strong aria-hidden="true">20.</strong> 用户界面</a></li><li class="chapter-item expanded affix "><li class="part-title">里程碑 3. 跨Tick交换</li><li class="chapter-item expanded "><a href="../milestone_3/introduction.html"><strong aria-hidden="true">21.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../milestone_3/different-ranges.html"><strong aria-hidden="true">22.</strong> 不同价格范围</a></li><li class="chapter-item expanded "><a href="../milestone_3/cross-tick-swaps.html"><strong aria-hidden="true">23.</strong> Cross-Tick 交换</a></li><li class="chapter-item expanded "><a href="../milestone_3/slippage-protection.html"><strong aria-hidden="true">24.</strong> 滑点保护</a></li><li class="chapter-item expanded "><a href="../milestone_3/liquidity-calculation.html"><strong aria-hidden="true">25.</strong> 流动性计算</a></li><li class="chapter-item expanded "><a href="../milestone_3/more-on-fixed-point-numbers.html"><strong aria-hidden="true">26.</strong> 关于定点数的更多内容</a></li><li class="chapter-item expanded "><a href="../milestone_3/flash-loans.html"><strong aria-hidden="true">27.</strong> 闪电贷</a></li><li class="chapter-item expanded "><a href="../milestone_3/user-interface.html"><strong aria-hidden="true">28.</strong> 用户界面</a></li><li class="chapter-item expanded affix "><li class="part-title">里程碑 4. 多池交换</li><li class="chapter-item expanded "><a href="../milestone_4/introduction.html"><strong aria-hidden="true">29.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../milestone_4/factory-contract.html"><strong aria-hidden="true">30.</strong> 工厂合约</a></li><li class="chapter-item expanded "><a href="../milestone_4/path.html"><strong aria-hidden="true">31.</strong> 交换路径</a></li><li class="chapter-item expanded "><a href="../milestone_4/multi-pool-swaps.html"><strong aria-hidden="true">32.</strong> 多池交换</a></li><li class="chapter-item expanded "><a href="../milestone_4/user-interface.html"><strong aria-hidden="true">33.</strong> 用户界面</a></li><li class="chapter-item expanded "><a href="../milestone_4/tick-rounding.html"><strong aria-hidden="true">34.</strong> Tick舍入</a></li><li class="chapter-item expanded affix "><li class="part-title">里程碑 5. 费用和价格预言机</li><li class="chapter-item expanded "><a href="../milestone_5/introduction.html"><strong aria-hidden="true">35.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../milestone_5/swap-fees.html"><strong aria-hidden="true">36.</strong> 交换费用</a></li><li class="chapter-item expanded "><a href="../milestone_5/flash-loan-fees.html"><strong aria-hidden="true">37.</strong> 闪电贷费用</a></li><li class="chapter-item expanded "><a href="../milestone_5/protocol-fees.html"><strong aria-hidden="true">38.</strong> 协议费用</a></li><li class="chapter-item expanded "><a href="../milestone_5/price-oracle.html"><strong aria-hidden="true">39.</strong> 价格预言机</a></li><li class="chapter-item expanded "><a href="../milestone_5/user-interface.html"><strong aria-hidden="true">40.</strong> 用户界面</a></li><li class="chapter-item expanded affix "><li class="part-title">里程碑 6: NFT 头寸</li><li class="chapter-item expanded "><a href="../milestone_6/introduction.html"><strong aria-hidden="true">41.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../milestone_6/erc721-overview.html"><strong aria-hidden="true">42.</strong> ERC721概述</a></li><li class="chapter-item expanded "><a href="../milestone_6/nft-manager.html"><strong aria-hidden="true">43.</strong> NFT管理器</a></li><li class="chapter-item expanded "><a href="../milestone_6/nft-renderer.html"><strong aria-hidden="true">44.</strong> NFT渲染器</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Uniswap V3 Development Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jeiwan/uniswapv3-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Jeiwan/uniswapv3-book/edit/main/src/milestone_1/providing-liquidity.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="providing-liquidity"><a class="header" href="#providing-liquidity">Providing Liquidity</a></h1>
<p>Enough of theory, let’s start coding!</p>
<p>Create a new folder (mine is called <code>uniswapv3-code</code>), and run <code>forge init --vscode</code> in it–this will initialize a Forge project. The <code>--vscode</code> flag tells Forge to configure the Solidity extension for Forge projects.</p>
<p>Next, remove the default contract and its test:</p>
<ul>
<li><code>script/Contract.s.sol</code></li>
<li><code>src/Contract.sol</code></li>
<li><code>test/Contract.t.sol</code></li>
</ul>
<p>And that’s it! Let’s create our first contract!</p>
<h2 id="pool-contract"><a class="header" href="#pool-contract">Pool Contract</a></h2>
<p>As you’ve learned from the introduction, Uniswap deploys multiple Pool contracts, each of which is an exchange market of a pair of tokens. Uniswap groups all its contracts into two categories:</p>
<ul>
<li>core contracts,</li>
<li>and periphery contracts.</li>
</ul>
<p>Core contracts are, as the name implies, contracts that implement core logic. These are minimal, user-<strong>un</strong>friendly, low-level contracts. Their purpose is to do one thing and do it as reliably and securely as possible. In Uniswap V3, there are 2 such contracts:</p>
<ol>
<li>Pool contract, which implements the core logic of a decentralized exchange.</li>
<li>Factory contract, which serves as a registry of Pool contracts and a contract that makes deployment of pools easier.</li>
</ol>
<p>We’ll begin with the pool contract, which implements 99% of the core functionality of Uniswap.</p>
<p>Create <code>src/UniswapV3Pool.sol</code>:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.14;

contract UniswapV3Pool {}
</code></pre>
<p>Let’s think about what data the contract will store:</p>
<ol>
<li>Since every pool contract is an exchange market of two tokens, we need to track the two token addresses. These addresses will be static, set once and forever during pool deployment (thus, they will be immutable).</li>
<li>Each pool contract is a set of liquidity positions. We’ll store them in a mapping, where keys are unique position identifiers and values are structs holding information about positions.</li>
<li>Each pool contract will also need to maintain a ticks registry–this will be a mapping with keys being tick indexes and values being structs storing information about ticks.</li>
<li>Since the tick range is limited, we need to store the limits in the contract, as constants.</li>
<li>Recall that pool contracts store the amount of liquidity, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>. So we’ll need to have a variable for it.</li>
<li>Finally, we need to track the current price and the related tick. We’ll store them in one storage slot to optimize gas consumption: these variables will be often read and written together, so it makes sense to benefit from <a href="https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html">the state variables packing feature of Solidity</a>.</li>
</ol>
<p>All in all, this is what we begin with:</p>
<pre><code class="language-solidity">// src/lib/Tick.sol
library Tick {
    struct Info {
        bool initialized;
        uint128 liquidity;
    }
    ...
}

// src/lib/Position.sol
library Position {
    struct Info {
        uint128 liquidity;
    }
    ...
}

// src/UniswapV3Pool.sol
contract UniswapV3Pool {
    using Tick for mapping(int24 =&gt; Tick.Info);
    using Position for mapping(bytes32 =&gt; Position.Info);
    using Position for Position.Info;

    int24 internal constant MIN_TICK = -887272;
    int24 internal constant MAX_TICK = -MIN_TICK;

    // Pool tokens, immutable
    address public immutable token0;
    address public immutable token1;

    // Packing variables that are read together
    struct Slot0 {
        // Current sqrt(P)
        uint160 sqrtPriceX96;
        // Current tick
        int24 tick;
    }
    Slot0 public slot0;

    // Amount of liquidity, L.
    uint128 public liquidity;

    // Ticks info
    mapping(int24 =&gt; Tick.Info) public ticks;
    // Positions info
    mapping(bytes32 =&gt; Position.Info) public positions;

    ...
</code></pre>
<p>Uniswap V3 uses many helper contracts and <code>Tick</code> and <code>Position</code> are two of them. <code>using A for B</code> is a feature of Solidity that lets you extend type <code>B</code> with functions from library contract <code>A</code>. This simplifies managing complex data structures.</p>
<blockquote>
<p>For brevity, I’ll omit a detailed explanation of Solidity syntax and features. Solidity has <a href="https://docs.soliditylang.org/en/latest/">great documentation</a>, don’t hesitate to refer to it if something is not clear!</p>
</blockquote>
<p>We’ll then initialize some of the variables in the constructor:</p>
<pre><code class="language-solidity">    constructor(
        address token0_,
        address token1_,
        uint160 sqrtPriceX96,
        int24 tick
    ) {
        token0 = token0_;
        token1 = token1_;

        slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick});
    }
}
</code></pre>
<p>Here, we’re setting the token address immutables and setting the current price and tick–we don’t need to provide liquidity for the latter.</p>
<p>This is our starting point, and our goal in this chapter is to make our first swap using pre-calculated and hard-coded values.</p>
<h2 id="minting"><a class="header" href="#minting">Minting</a></h2>
<p>The process of providing liquidity in Uniswap V2 is called <em>minting</em>. The reason is that the V2 pool contract mints tokens (LP-tokens) in exchange for liquidity. V3 doesn’t do that, but it still uses the same name for the function. Let’s use it as well:</p>
<pre><code class="language-solidity">function mint(
    address owner,
    int24 lowerTick,
    int24 upperTick,
    uint128 amount
) external returns (uint256 amount0, uint256 amount1) {
    ...
</code></pre>
<p>Our <code>mint</code> function will take:</p>
<ol>
<li>Owner’s address, to track the owner of the liquidity.</li>
<li>Upper and lower ticks, to set the bounds of a price range.</li>
<li>The amount of liquidity we want to provide.</li>
</ol>
<blockquote>
<p>Notice that user specifies <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>, not actual token amounts. This is not very convenient of course, but recall that the Pool contract is a core contract–it’s not intended to be user-friendly because it should implement only the core logic.  In a later chapter, we’ll make a helper contract that will convert token amounts to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> before calling <code>Pool.mint</code>.</p>
</blockquote>
<p>Let’s outline a quick plan of how minting will work:</p>
<ol>
<li>a user specifies a price range and an amount of liquidity;</li>
<li>the contract updates the <code>ticks</code> and <code>positions</code> mappings;</li>
<li>the contract calculates token amounts the user must send (we’ll pre-calculate and hard code them);</li>
<li>the contract takes tokens from the user and verifies that the correct amounts were set.</li>
</ol>
<p>Let’s begin with checking the ticks:</p>
<pre><code class="language-solidity">if (
    lowerTick &gt;= upperTick ||
    lowerTick &lt; MIN_TICK ||
    upperTick &gt; MAX_TICK
) revert InvalidTickRange();
</code></pre>
<p>And ensuring that some amount of liquidity is provided:</p>
<pre><code class="language-solidity">if (amount == 0) revert ZeroLiquidity();
</code></pre>
<p>Then, add a tick and a position:</p>
<pre><code class="language-solidity">ticks.update(lowerTick, amount);
ticks.update(upperTick, amount);

Position.Info storage position = positions.get(
    owner,
    lowerTick,
    upperTick
);
position.update(amount);
</code></pre>
<p>The <code>ticks.update</code> function is:</p>
<pre><code class="language-solidity">// src/lib/Tick.sol
function update(
    mapping(int24 =&gt; Tick.Info) storage self,
    int24 tick,
    uint128 liquidityDelta
) internal {
    Tick.Info storage tickInfo = self[tick];
    uint128 liquidityBefore = tickInfo.liquidity;
    uint128 liquidityAfter = liquidityBefore + liquidityDelta;

    if (liquidityBefore == 0) {
        tickInfo.initialized = true;
    }

    tickInfo.liquidity = liquidityAfter;
}
</code></pre>
<p>It initializes a tick if it has 0 liquidity and adds new liquidity to it. As you can see, we’re calling this function on both lower and upper ticks, thus liquidity is added to both of them.</p>
<p>The <code>position.update</code> function is:</p>
<pre><code class="language-solidity">// src/libs/Position.sol
function update(Info storage self, uint128 liquidityDelta) internal {
    uint128 liquidityBefore = self.liquidity;
    uint128 liquidityAfter = liquidityBefore + liquidityDelta;

    self.liquidity = liquidityAfter;
}
</code></pre>
<p>Similar to the tick update function, it adds liquidity to a specific position. To get a position we call:</p>
<pre><code class="language-solidity">// src/libs/Position.sol
...
function get(
    mapping(bytes32 =&gt; Info) storage self,
    address owner,
    int24 lowerTick,
    int24 upperTick
) internal view returns (Position.Info storage position) {
    position = self[
        keccak256(abi.encodePacked(owner, lowerTick, upperTick))
    ];
}
...
</code></pre>
<p>Each position is uniquely identified by three keys: owner address, lower tick index, and upper tick index.  We hash the three to make storing data cheaper: when hashed, every key will take 32 bytes, instead of 96 bytes when <code>owner</code>, <code>lowerTick</code>, and <code>upperTick</code> are separate keys.</p>
<blockquote>
<p>If we use three keys, we need three mappings. Each key would be stored separately and would take 32 bytes since Solidity stores values in 32-byte slots (when packing is not applied).</p>
</blockquote>
<p>Next, continuing with minting, we need to calculate the amounts that the user must deposit. Luckily, we have already figured out the formulas and calculated the exact amounts in the previous part. So, we’re going to hard-code them:</p>
<pre><code class="language-solidity">amount0 = 0.998976618347425280 ether;
amount1 = 5000 ether;
</code></pre>
<blockquote>
<p>We’ll replace these with actual calculations in a later chapter.</p>
</blockquote>
<p>We will also update the <code>liquidity</code> of the pool, based on the <code>amount</code> being added.</p>
<pre><code class="language-solidity">liquidity += uint128(amount);
</code></pre>
<p>Now, we’re ready to take tokens from the user. This is done via a callback:</p>
<pre><code class="language-solidity">function mint(...) ... {
    ...

    uint256 balance0Before;
    uint256 balance1Before;
    if (amount0 &gt; 0) balance0Before = balance0();
    if (amount1 &gt; 0) balance1Before = balance1();
    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
        amount0,
        amount1
    );
    if (amount0 &gt; 0 &amp;&amp; balance0Before + amount0 &gt; balance0())
        revert InsufficientInputAmount();
    if (amount1 &gt; 0 &amp;&amp; balance1Before + amount1 &gt; balance1())
        revert InsufficientInputAmount();

    ...
}

function balance0() internal returns (uint256 balance) {
    balance = IERC20(token0).balanceOf(address(this));
}

function balance1() internal returns (uint256 balance) {
    balance = IERC20(token1).balanceOf(address(this));
}
</code></pre>
<p>First, we record current token balances. Then we call the <code>uniswapV3MintCallback</code> method on the caller–this is the callback.  It’s expected that the caller (whoever calls <code>mint</code>) is a contract because non-contract addresses cannot implement functions in Ethereum. Using a callback here, while not being user-friendly at all, lets the contract calculate token amounts using its current state–this is critical because we cannot trust users.</p>
<p>The caller is expected to implement <code>uniswapV3MintCallback</code> and transfer tokens to the Pool contract in this function.  After calling the callback function, we continue with checking whether the Pool contract balances have changed or not: we require them to increase by at least <code>amount0</code> and <code>amount1</code> respectively–this would mean the caller has transferred tokens to the pool.</p>
<p>Finally, we’re firing a <code>Mint</code> event:</p>
<pre><code class="language-solidity">emit Mint(msg.sender, owner, lowerTick, upperTick, amount, amount0, amount1);
</code></pre>
<p>Events is how contract data is indexed in Ethereum for later search. It’s a good practice to fire an event whenever the contract’s state is changed to let blockchain explorer know when this happened. Events also carry useful information. In our case, it’s the caller’s address, the liquidity position owner’s address, upper and lower ticks, new liquidity, and token amounts. This information will be stored as a log, and anyone else will be able to collect all contract events and reproduce the activity of the contract without traversing and analyzing all blocks and transactions.</p>
<p>And we’re done! Phew! Now, let’s test minting.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>At this point, we don’t know if everything works correctly. Before deploying our contract anywhere we’re going to write a bunch of tests to ensure the contract works correctly. Luckily for us, Forge is a great testing framework and it’ll make testing a breeze. </p>
<p>Create a new test file:</p>
<pre><code class="language-solidity">// test/UniswapV3Pool.t.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.14;

import &quot;forge-std/Test.sol&quot;;

contract UniswapV3PoolTest is Test {
    function setUp() public {}

    function testExample() public {
        assertTrue(true);
    }
}
</code></pre>
<p>Let’s run it:</p>
<pre><code class="language-shell">$ forge test
Running 1 test for test/UniswapV3Pool.t.sol:UniswapV3PoolTest
[PASS] testExample() (gas: 279)
Test result: ok. 1 passed; 0 failed; finished in 5.07ms
</code></pre>
<p>It passes! Of course, it is! So far, our test only checks that <code>true</code> is <code>true</code>!</p>
<p>Test contracts are just contracts that inherit from <code>forge-std/Test.sol</code>. This contract is a set of testing utilities, we’ll get acquainted with them step by step. If you don’t want to wait, open <code>lib/forge-std/src/Test.sol</code> and skim through it.</p>
<p>Test contracts follow a specific convention:</p>
<ol>
<li><code>setUp</code> function is used to set up test cases. In each test case, we want to have a configured environment, like deployed contracts, minted tokens, and initialized pools–we’ll do all this in <code>setUp</code>.</li>
<li>Every test case starts with the <code>test</code> prefix, e.g. <code>testMint()</code>. This will let Forge distinguish test cases from helper functions (we can also have any function we want).</li>
</ol>
<p>Let’s now actually test minting.</p>
<h3 id="test-tokens"><a class="header" href="#test-tokens">Test Tokens</a></h3>
<p>To test minting we need tokens. This is not a problem because we can deploy any contract in tests! Moreover, Forge can install open-source contracts as dependencies. Specifically, we need an ERC20 contract with minting functionality. We’ll use the ERC20 contract from <a href="https://github.com/Rari-Capital/solmate">Solmate</a>, a collection of gas-optimized contracts, and make an ERC20 contract that inherits from the Solmate contract and exposes minting (it’s public by default).</p>
<p>Let’s install <code>solmate</code>:</p>
<pre><code class="language-shell">$ forge install rari-capital/solmate
</code></pre>
<p>Then, let’s create the <code>ERC20Mintable.sol</code> contract in the <code>test</code> folder (we’ll use the contract only in tests):</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.14;

import &quot;solmate/tokens/ERC20.sol&quot;;

contract ERC20Mintable is ERC20 {
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) ERC20(_name, _symbol, _decimals) {}

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}
</code></pre>
<p>Our <code>ERC20Mintable</code> inherits all functionality from <code>solmate/tokens/ERC20.sol</code> and we additionally implement the public <code>mint</code> method which will allow us to mint any number of tokens.</p>
<h3 id="minting-1"><a class="header" href="#minting-1">Minting</a></h3>
<p>Now, we’re ready to test minting.</p>
<p>First, let’s deploy all the required contracts:</p>
<pre><code class="language-solidity">// test/UniswapV3Pool.t.sol
...
import &quot;./ERC20Mintable.sol&quot;;
import &quot;../src/UniswapV3Pool.sol&quot;;

contract UniswapV3PoolTest is Test {
    ERC20Mintable token0;
    ERC20Mintable token1;
    UniswapV3Pool pool;

    function setUp() public {
        token0 = new ERC20Mintable(&quot;Ether&quot;, &quot;ETH&quot;, 18);
        token1 = new ERC20Mintable(&quot;USDC&quot;, &quot;USDC&quot;, 18);
    }

    ...
</code></pre>
<p>In the <code>setUp</code> function, we deploy tokens but not pools! This is because all our test cases will use the same tokens but each of them will have a unique pool.</p>
<p>To make the setting up of pools cleaner and simpler, we’ll do this in a separate function, <code>setupTestCase</code>, that takes a set of test case parameters. In our first test case, we’ll test successful liquidity minting. This is what the test case parameters look like:</p>
<pre><code class="language-solidity">function testMintSuccess() public {
    TestCaseParams memory params = TestCaseParams({
        wethBalance: 1 ether,
        usdcBalance: 5000 ether,
        currentTick: 85176,
        lowerTick: 84222,
        upperTick: 86129,
        liquidity: 1517882343751509868544,
        currentSqrtP: 5602277097478614198912276234240,
        shouldTransferInCallback: true,
        mintLiqudity: true
    });
</code></pre>
<ol>
<li>We’re planning to deposit 1 ETH and 5000 USDC into the pool.</li>
<li>We want the current tick to be 85176, and the lower and upper ticks to be 84222 and 86129 respectively (we calculated these values in the previous chapter).</li>
<li>We’re specifying the precalculated liquidity and current <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1133em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9267em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span><span style="top:-2.8867em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1133em;"><span></span></span></span></span></span></span></span></span>.</li>
<li>We also want to deposit liquidity (<code>mintLiquidity</code> parameter) and transfer tokens when requested by the pool contract
(<code>shouldTransferInCallback</code>). We don’t want to do this in each test case, so we want to have the flags.</li>
</ol>
<p>Next, we’re calling <code>setupTestCase</code> with the above parameters:</p>
<pre><code class="language-solidity">function setupTestCase(TestCaseParams memory params)
    internal
    returns (uint256 poolBalance0, uint256 poolBalance1)
{
    token0.mint(address(this), params.wethBalance);
    token1.mint(address(this), params.usdcBalance);

    pool = new UniswapV3Pool(
        address(token0),
        address(token1),
        params.currentSqrtP,
        params.currentTick
    );

    if (params.mintLiqudity) {
        (poolBalance0, poolBalance1) = pool.mint(
            address(this),
            params.lowerTick,
            params.upperTick,
            params.liquidity
        );
    }

    shouldTransferInCallback = params.shouldTransferInCallback;
}
</code></pre>
<p>In this function, we’re minting tokens and deploying a pool. Also, when the <code>mintLiquidity</code> flag is set, we mint liquidity in the pool. In the end, we’re setting the <code>shouldTransferInCallback</code> flag for it to be read in the mint callback:</p>
<pre><code class="language-solidity">function uniswapV3MintCallback(uint256 amount0, uint256 amount1) public {
    if (shouldTransferInCallback) {
        token0.transfer(msg.sender, amount0);
        token1.transfer(msg.sender, amount1);
    }
}
</code></pre>
<p>It’s the test contract that will provide liquidity and will call the <code>mint</code> function on the pool, there’re no users. The test contract will act as a user, thus it can implement the mint callback function.</p>
<p>Setting up test cases like that is not mandatory, you can do it however feels most comfortable to you. Test contracts are just contracts.</p>
<p>In <code>testMintSuccess</code>, we want to ensure that the pool contract:</p>
<ol>
<li>takes the correct amounts of tokens from us;</li>
<li>creates a position with correct key and liquidity;</li>
<li>initializes the upper and lower ticks we’ve specified;</li>
<li>has correct <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1133em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9267em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span><span style="top:-2.8867em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1133em;"><span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>.</li>
</ol>
<p>Let’s do this.</p>
<p>Minting happens in <code>setupTestCase</code>, so we don’t need to do this again. The function also returns the amounts we have provided, so let’s check them:</p>
<pre><code class="language-solidity">(uint256 poolBalance0, uint256 poolBalance1) = setupTestCase(params);

uint256 expectedAmount0 = 0.998976618347425280 ether;
uint256 expectedAmount1 = 5000 ether;
assertEq(
    poolBalance0,
    expectedAmount0,
    &quot;incorrect token0 deposited amount&quot;
);
assertEq(
    poolBalance1,
    expectedAmount1,
    &quot;incorrect token1 deposited amount&quot;
);
</code></pre>
<p>We expect specific pre-calculated amounts. And we can also check that these amounts were transferred to the pool:</p>
<pre><code class="language-solidity">assertEq(token0.balanceOf(address(pool)), expectedAmount0);
assertEq(token1.balanceOf(address(pool)), expectedAmount1);
</code></pre>
<p>Next, we need to check the position the pool created for us. Remember that the key in <code>positions</code> mapping is a hash? We need to calculate it manually and then get our position from the contract:</p>
<pre><code class="language-solidity">bytes32 positionKey = keccak256(
    abi.encodePacked(address(this), params.lowerTick, params.upperTick)
);
uint128 posLiquidity = pool.positions(positionKey);
assertEq(posLiquidity, params.liquidity);
</code></pre>
<blockquote>
<p>Since <code>Position.Info</code> is a <a href="https://docs.soliditylang.org/en/latest/types.html#structs">struct</a>, it gets destructured when fetched: each field gets assigned to a separate variable.</p>
</blockquote>
<p>Next, come the ticks. Again, it’s straightforward:</p>
<pre><code class="language-solidity">(bool tickInitialized, uint128 tickLiquidity) = pool.ticks(
    params.lowerTick
);
assertTrue(tickInitialized);
assertEq(tickLiquidity, params.liquidity);

(tickInitialized, tickLiquidity) = pool.ticks(params.upperTick);
assertTrue(tickInitialized);
assertEq(tickLiquidity, params.liquidity);
</code></pre>
<p>And finally, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1133em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9267em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span><span style="top:-2.8867em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1133em;"><span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>:</p>
<pre><code class="language-solidity">(uint160 sqrtPriceX96, int24 tick) = pool.slot0();
assertEq(
    sqrtPriceX96,
    5602277097478614198912276234240,
    &quot;invalid current sqrtP&quot;
);
assertEq(tick, 85176, &quot;invalid current tick&quot;);
assertEq(
    pool.liquidity(),
    1517882343751509868544,
    &quot;invalid current liquidity&quot;
);
</code></pre>
<p>As you can see, writing tests in Solidity is not hard!</p>
<h3 id="failures"><a class="header" href="#failures">Failures</a></h3>
<p>Of course, testing only successful scenarios is not enough. We also need to test failing cases. What can go wrong when providing liquidity? Here are a couple of hints:</p>
<ol>
<li>Upper and lower ticks are too big or too small.</li>
<li>Zero liquidity is provided.</li>
<li>The liquidity provider doesn’t have enough tokens.</li>
</ol>
<p>I’ll leave it to you to implement these scenarios! Feel free to peek at <a href="https://github.com/Jeiwan/uniswapv3-code/blob/milestone_1/test/UniswapV3Pool.t.sol">the code in the repo</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../milestone_1/calculating-liquidity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../milestone_1/first-swap.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../milestone_1/calculating-liquidity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../milestone_1/first-swap.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
